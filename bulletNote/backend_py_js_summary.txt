===== Python & JS Files Summary - backend =====
Root Directory: D:\work\project\bulletNote
Target Folder: D:\work\project\bulletNote\backend
Target File Types: .js, .py
Skipped Folders: node_modules
Traversal Order: Directory Tree (Parent â†’ Child, sorted by filename)
====================================================================================================

[FILE] backend\app.js
--------------------------------------------------------------------------------
Content:
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const { connectDB } = require('./config/db');
const userRoutes = require('./routes/userRoutes');
const noteRoutes = require('./routes/noteRoutes');
const cookieParser = require('cookie-parser');
const swaggerDocument = require('./swagger_output.json');
const swaggerUi = require('swagger-ui-express');


if (process.env.NODE_ENV !== "development") {
  console.log = () => {};          
  console.debug = () => {};        
}
// initialize application
const app = express();
const PORT = process.env.PORT || 5000;

app.use(express.json());                     
app.use(express.urlencoded({ extended: true })); 
app.use(cookieParser());

// middlewear
app.use(cors({
  origin: true,
  credentials: true, //Allowed to cross origin with cookie
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'X-Skip-Alert']
})); 

app.use((req, res, next) => {
  if (process.env.Request == 1) {console.log(`ã€Global request logã€‘${req.method} ${req.url} - body:`, req.body);}
  next();
});
//connect database
connectDB();

//router
app.use('/api/users', userRoutes);
app.use('/api/notes', noteRoutes);
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument));
//error handle
app.use((err, req, res, next) => {
  console.error('Global error:', err);
  res.status(500).json({ success: false, message: 'Server error' });
});

// route testing
app.get('/', (req, res) => {
  res.send(' Bullet Note backend is running');
});

// launch
app.listen(PORT, () => {
  console.log(`ðŸš€ running on http://localhost:${PORT}`);
});
====================================================================================================

[FILE] backend\swagger.js
--------------------------------------------------------------------------------
Content:
const swaggerAutogen = require('swagger-autogen')();

const doc = {
  info: {
    title: 'Bullet Note API documentation',        
    version: '1.0.0',                   
    description: 'Bullet Note backend interface documentation' // descripition
  },
  servers: [
    {
      url: 'http://localhost:5000',       
      description: 'development server'        
    }
  ],
  components: {
    schemas: {
      SuccessResponse: {
        type: 'object',
        properties: {
          success: { type: 'boolean', example: true },
          message: { type: 'string', example: 'success' },
          data: { type: 'object' }
        }
      },
      ErrorResponse: {
        type: 'object',
        properties: {
          success: { type: 'boolean', example: false },
          message: { type: 'string', example: 'failure' }
        }
      }
    },
    securitySchemes: {
      cookieAuth: {
        type: 'apiKey',
        in: 'cookie',
        name: 'note_token' 
      }
    }
  }
};

const outputFile = './swagger_output.json'; 
const endpointsFiles = [
  './routes/userRoutes.js',  
  './routes/noteRoutes.js'   
];

swaggerAutogen(outputFile, endpointsFiles, doc).then(() => {
  console.log('âœ… Swagger é…ç½®æ–‡ä»¶ç”ŸæˆæˆåŠŸï¼');
});
====================================================================================================

[FILE] backend\config\config.js
--------------------------------------------------------------------------------
Content:
require('dotenv').config();

module.exports = {
  development: {
    username: process.env.MYSQL_USER,
    password: process.env.MYSQL_PASSWORD,
    database: process.env.MYSQL_DB_NAME,
    host: process.env.MYSQL_HOST || '127.0.0.1',
    dialect: process.env.DB_DIALECT || 'mysql',
    port: process.env.MYSQL_PORT || 3306,
    ssl: process.env.DB_SSL === 'true'
  },
  production: {
    username: process.env.MYSQL_USER,
    password: process.env.MYSQL_PASSWORD,
    database: process.env.MYSQL_DB_NAME,
    host: process.env.MYSQL_HOST || '127.0.0.1',
    dialect: process.env.DB_DIALECT || 'mysql',
    port: process.env.MYSQL_PORT || 3306,
    ssl: true
  }

};
====================================================================================================

[FILE] backend\config\db.js
--------------------------------------------------------------------------------
Content:
const { Sequelize } = require('sequelize');  //ORM tool
require('dotenv').config();
const config = require('./config');
const fs = require('fs');
const path = require('path');

const env = process.env.NODE_ENV || 'development';
const dbConfig = config[env]
const sequelize = new Sequelize(
    dbConfig.database,
    dbConfig.username,
    dbConfig.password,
    {
        host: dbConfig.host,
        dialect: dbConfig.dialect,
        port: dbConfig.port,
        logging: false, // closed sql log
        pool: {
            max: 5,
            min: 0,
            acquire: 30000,
            idle: 10000
        },
        ssl: dbConfig.ssl,
        dialectOptions: dbConfig.ssl ? {
            ssl: {
                rejectUnauthorized: true,
                ca: fs.readFileSync(path.resolve(__dirname, 'ca.pem'))
            }
    } : {}
    }
);

//connection
const connectDB = async () => {
    try {
        await sequelize.authenticate();
        console.log('Connect successfully');

        await sequelize.sync({ alter: true
                            });  //synchronous content betweeb the database and project
        console.log('Synchronization completed')
    } catch (error) {
        console.error('MySQL connection failed: ', error.message);
        process.exit(1);
    }
};

module.exports={ sequelize, connectDB}
====================================================================================================

[FILE] backend\controllers\noteController.js
--------------------------------------------------------------------------------
Content:
const {Note, User} = require('../models');
const { protect } = require('../middleware/auth.middleware');
const { createAspect } = require('../utils/aspect');

const getNotes = async (req, res) => {
    console.log('starting to load notes')
    const userId = req.user.id;
    const notes = await Note.findAll({
        where: {userId: req.user.id},
        order: [['createdAt', 'DESC']],
        include: [
            {
                model: User,
                as: 'author',
            }
        ] 
    });
    res.status(200).json({
        success: true,
        message: 'Successfully loading notes',
        data: notes.map(note => note.toJSON())
    });
};

const createNote = async (req, res) => {
    console.log('creating note')
    const userId = req.user.id;
    const {title, content, category} = req.body;

    if (!title || !content) {
        return res.status(400).json({
            success: false,
            message: 'Cannot be empty'});
    }
    const newNote = await Note.create({
        userId,
        title,
        content,
        category: category || 'default',
    });
    res.status(201).json({
        success: true,
        data: newNote
    });
};

const updateNote = async (req,res) => {
    const userId = req.user.id;
    const {id} = req.params;
    const {title, content, category} = req.body;

    const note = await Note.findOne({
        where: {
            id,
            userId
        }
    });
    if (!note) {
        return res.status(404).json({
            success: false,
            message: 'Note does not exist'})
    }

    await note.update({
        title: title || note.title,
        content: content || note.content,
        category: category || note.category
    });

    res.status(200).json({
        success: true,
        data: note
    }
    );
};

const deleteNote = async (req, res) => {
    const { id } = req.params;
    const userId = req.user.id;

    const note = await Note.findOne({
        where: {
            id,
            userId
        }
    });
    if(!note) {
        return res.status(404).json({
            success: false,
            message: 'Note does not exist'});
    }
    await note.destroy();
    res.status(200).json({
        success: true,
        message: 'Deleted note successfully'});
};

const getNoteByTitle = async (req, res) => {
    const { name } = req.params;
    const userId = req.user.id;

    const note = await Note.findAll({
        where: {
            title: name,
            userId
        },
        order: [['createdAt', 'DESC']]
    });
    if(!note) {
        return res.status(404).json({
            success: false,
            message: 'Note does not exist'});
    }
    res.status(200).json({
        success: true,
        data: note
    });
};

exports.getNotes = createAspect(getNotes);
exports.createNote = createAspect(createNote);
exports.updateNote = createAspect(updateNote);
exports.deleteNote = createAspect(deleteNote);
exports.getNoteByTitle = createAspect(getNoteByTitle);
====================================================================================================

[FILE] backend\controllers\userController.js
--------------------------------------------------------------------------------
Content:
const User = require('../models/User');
const { JWT_EXPIRES_IN, Op } = require('../models/User');
const { createAspect } = require('../utils/aspect');


//registration
registration = async (req, res) => {
    const {username, password, email} = req.body || {};
    //params validation
    if (!username || !password) {
        return res.status(400).json({
            success: false,
            message: 'Username and password cannot be empty.'
        });
    }
    //existaing validation
    const existingUser = await User.findOne({
        where: {
            [Op.or]: [{username: username}, {email: email}]
        }
    });
    if (existingUser) {
        console.log("existing user");
        return res.status(400).json({
            success: false,
            message: 'Username or email address has been registered.'
        });
    }
    //Create user
    const user = await User.create({
        username,
        password,
        email: email || null
    });
    //return result
    res.status(201).json({
        success: true,
        message: 'register successfully',
        data: {
            id: user.id,
            username: user.username,
            email: user.email
        }
    }); 
}



login = async (req, res) => {
    //get params from frontend
    const {usernameOrEmail, password} = req.body || {};
    //params validation
    if (!usernameOrEmail || !password) {
        console.log("empty")
        return res.status(400).json({
            success: false,
            message: 'Username/Email and password cannot be empty.'
        });
    }
    //existing validation
    const existingUser = await User.findOne({
        where: {
            [Op.or]: [{username: usernameOrEmail}, {email: usernameOrEmail}]
        }
    });
    if (!existingUser) {
        console.log("no user");
        return res.status(401).json({
            success: false,
            message: 'Incorrect username/email or password'
        });
    }
    console.log("detected user")
    //Validate password
    const isPwdCorrect = await existingUser.comparePassword(password);
    if (!isPwdCorrect) {
        console.log("password error")
        return res.status(401).json({
            success: false,
            message: 'Incorrect username or password'
        });
    }
    const token = existingUser.generateToken();
    console.log("create token")
    res.cookie(
        'note_token',
        token,
        {
            httpOnly: true,
            maxAge: JWT_EXPIRES_IN * 1000,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'none',
            path: '/'
        }
    );
    return res.status(200).json({
        success: true,
        message: 'Login successfully',
        data: {
            id: existingUser.id,
            username: existingUser.username,
            email: existingUser.email || ''
        }
    })
}


getUserInfo = async (req, res) => {
    const userInfo = req.user;
    return res.status(200).json({
        success: true,
        message: 'Get user info successfully',
        data: userInfo
    });
} 

logout = async (req,res) => {
    res.clearCookie('note_token', {
        httpOnly: true,
        sameSite: 'strict',
        path: '/'
    })
     res.status(200).json({
        success: true,
        message: 'Logout successfully'
     });
} 
exports.wrapperRegisteration = createAspect(registration);
exports.wrapperLogin = createAspect(login);
exports.wrapperGetUserInfo = createAspect(getUserInfo);
exports.wrapperLogout = createAspect(logout);

====================================================================================================

[FILE] backend\middleware\auth.middleware.js
--------------------------------------------------------------------------------
Content:
const jwt = require('jsonwebtoken');
require('dotenv').config();
const JWT_SECRET = process.env.JWT_SECRET;
const DEBOUNCE_TIME = 300;
const authDebounceCache = new Map();

//Token validation
const protect = async (req, res, next) => {
    try {
        const requestKey = `${req.ip}_${req.method}_${req.originalUrl}`;
        const cacheData = authDebounceCache.get(requestKey);
        
        if (cacheData && Date.now() < cacheData.expireTime) {
            req.user = cacheData.user; 
            return next();
        }

        const token = req.cookies.note_token;
        if(!token) {
            return res.status(401).json({
                success: false,
                message: 'Unauthorized, please log in first.'
            });
        }
        const decoded = jwt.verify(token, JWT_SECRET);
        req.user = {
            id: decoded.id,
            username: decoded.username
        };

        authDebounceCache.set(requestKey, {
            expireTime: Date.now() + DEBOUNCE_TIME,
            user: req.user 
        });
        setTimeout(() => authDebounceCache.delete(requestKey), DEBOUNCE_TIME);

        next(); 
    } catch(err) {
        console.error('Failure to verify token', err.message);
        return res.status(401).json({
            success: false,
            message: 'Your login has expired. Please log in again.'
        })
    }
};

module.exports = {protect};
====================================================================================================

[FILE] backend\models\Note.js
--------------------------------------------------------------------------------
Content:
const { DataTypes} = require('sequelize');
const { sequelize } = require('../config/db');


//Note model
const Note = sequelize.define('Note', { //type name
    title: {
        type: DataTypes.STRING(100),
        allowNull: false
    },
    content: {
        type: DataTypes.TEXT,
        allowNull: false
    },
    category: {
        type: DataTypes.STRING(50),
        defaultValue:'default'
    },
    userId: {
        type: DataTypes.INTEGER,
        allowNull: false,
        onUpdate: 'CASCADE',
        onDelete: 'CASCADE'

    }
}, {
    tableName: 'notes',
    timestamps: true
});



module.exports = Note;
====================================================================================================

[FILE] backend\models\User.js
--------------------------------------------------------------------------------
Content:
const { DataTypes, Op } = require('sequelize');
const { sequelize } = require('../config/db');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
require('dotenv').config();

const JWT_SECRET = process.env.JWT_SECRET;
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || 60 * 60 * 24 * 7;

//User model
const User = sequelize.define('User', {
    username: {
        type: DataTypes.STRING(10),
        allowNull: false
    },
    password: {
        type: DataTypes.STRING(100),
        allowNull: false
    },
    email: {
        type: DataTypes.STRING(100)
    },
}, {
    tableName: 'users',
    timestamps: true
});


User.beforeCreate(async (user) => {
    const salt = await bcrypt.genSalt(10);
    user.password = await bcrypt.hash(user.password, salt)
});

User.beforeUpdate(async (user) => {
    if (user.changed('password')){
        const salt = await bcrypt.genSalt(10);
        user.password = await bcrypt.hash(user.password, salt)
    }
});

User.prototype.comparePassword = async function (plainPassword) {
    return await bcrypt.compare(plainPassword, this.password);
}

User.prototype.generateToken = function () {
    return jwt.sign(
        {id: this.id, username: this.username}, //store them in token
        JWT_SECRET,
        { expiresIn: JWT_EXPIRES_IN }

    );
};
module.exports = User;
module.exports.JWT_SECRET = JWT_SECRET;
module.exports.JWT_EXPIRES_IN = JWT_EXPIRES_IN;
module.exports.Op = Op;
====================================================================================================

[FILE] backend\models\index.js
--------------------------------------------------------------------------------
Content:
const { sequelize } = require('../config/db');
const User = require('./User');
const Note = require('./Note');
//Connect User table and Note table
User.hasMany(Note, {
    foreignKey: 'userId',
    onDelete: 'CASCADE',
    onUpdate: 'CASCADE',
    sourceKey: 'id'
})

Note.belongsTo(User, {
    foreignKey: 'userId',
    as: 'author',
    targetKey: 'id'
})
module.exports = {
    User,
    Note,
    sequelize 
};
====================================================================================================

[FILE] backend\routes\noteRoutes.js
--------------------------------------------------------------------------------
Content:
const express = require('express');
const router = express.Router();
const { protect } = require('../middleware/auth.middleware');

const {
  getNotes,
  createNote,
  updateNote,
  deleteNote,
  getNoteByTitle
} = require('../controllers/noteController');

router.use(protect);
router.get('/', getNotes);
router.get('/title/:name', getNoteByTitle); 
router.post('/', createNote); 
router.put('/:id', updateNote); 
router.delete('/:id', deleteNote); 

module.exports = router;
====================================================================================================

[FILE] backend\routes\userRoutes.js
--------------------------------------------------------------------------------
Content:
const express = require('express');
const router = express.Router();
const { protect } = require('../middleware/auth.middleware');
const {
    wrapperRegisteration,
    wrapperLogin,
    wrapperLogout,
    wrapperGetUserInfo
} = require('../controllers/userController');

router.post('/login', wrapperLogin);
router.post('/register', wrapperRegisteration);
router.get('/info', protect, wrapperGetUserInfo);
router.post('/logout', protect, wrapperLogout);

module.exports = router;
====================================================================================================

[FILE] backend\seeders\20260124233640-initial-users.js
--------------------------------------------------------------------------------
Content:
'use strict';

const bcrypt = require('bcryptjs');

module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.bulkInsert('Users', [
      {
        username: 'root',
        password: await bcrypt.hash('root', 12),  
        email: 'root@example.com',
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      {
        username: 'admin',
        password: await bcrypt.hash('admin', 12),
        email: 'admin@gmail.com',
        createdAt: new Date(),
        updatedAt: new Date(),
      },
    ], {});
  },

  async down(queryInterface, Sequelize) {
    await queryInterface.bulkDelete('Users', {
      username: ['admin', 'root'],
    }, {});
  }
};
====================================================================================================

[FILE] backend\utils\aspect.js
--------------------------------------------------------------------------------
Content:

function printResult(...args) {
    const isPrint = process.env.PrintResult === "1";
    if (isPrint) { 
        console.log(...args); 
    }
}

function formatTime(timestamp) {
    const date = new Date(timestamp);
    const pad = n => n.toString().padStart(2, '0');
    const pad3 = n => n.toString().padStart(3, '0'); 
    return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ` +
           `${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}.${pad3(date.getMilliseconds())}`;
}


exports.createAspect = (fn) => {
    //Validate parameter
    if(typeof fn !== 'function') {
        throw new Error('The element in list should be function');
    }
    const fnName = fn.name

    return async function(...args) {
        const startTime = Date.now();
        console.log(`Aspect log [${formatTime(startTime)}]: ${fnName} start to run`);
        try {
            //execute function
            const result = await fn.apply(this, args);

            //success
            const endTime = Date.now();
            console.log(`Aspect log [${formatTime(endTime)}]: ${fnName} run success, cost ${endTime - startTime}ms`);
            printResult(result);
            return result;
        } catch (error) {
            const errorTime = Date.now();
            console.error(`Aspect log [${formatTime(errorTime)}]: ${fnName} run failed`, error);
            const [, res] = args;
            if (res && typeof res.status === 'function' && typeof res.json === 'function') {
                res.status(500).json({
                    success: false,
                    message: 'Server error'
                });
        }
    }
};
}

====================================================================================================

